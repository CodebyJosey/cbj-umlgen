using Cbj.UmlGen.Application.Abstractions;
using Cbj.UmlGen.Domain.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;

namespace Cbj.UmlGen.Infrastructure.Roslyn;

/// <summary>
/// Loads C# solutions/projects using Roslyn and builds a <see cref="Codebase"/> model.
/// </summary>
public sealed class RoslynCodebaseLoader : ICodebaseLoader
{
    /// <inheritdoc />
    public async Task<Codebase> LoadAsync(string sourcePath, CancellationToken ct = default)
    {
        string? entry = ResolveEntryPoint(sourcePath);

        using MSBuildWorkspace? workspace = MSBuildWorkspace.Create();

        Solution? solution = entry.EndsWith(".sln", StringComparison.OrdinalIgnoreCase)
            ? await workspace.OpenSolutionAsync(entry, cancellationToken: ct)
            : (await workspace.OpenProjectAsync(entry, cancellationToken: ct)).Solution;

        List<ProjectModel>? projects = new List<ProjectModel>();

        foreach (Project? project in solution.Projects)
        {
            ct.ThrowIfCancellationRequested();

            Compilation? compilation = await project.GetCompilationAsync(ct);
            if (compilation is null)
            {
                continue;
            }

            List<TypeModel>? types = new List<TypeModel>();

            foreach (SyntaxTree? tree in compilation.SyntaxTrees)
            {
                ct.ThrowIfCancellationRequested();

                SemanticModel? semanticModel = compilation.GetSemanticModel(tree);
                SyntaxNode? root = await tree.GetRootAsync(ct);

                foreach (INamedTypeSymbol? declaredSymbol in root.DescendantNodes()
                             .Select(n => semanticModel.GetDeclaredSymbol(n))
                             .OfType<INamedTypeSymbol>())
                {
                    if (declaredSymbol is null)
                    {
                        continue;
                    }

                    if (declaredSymbol.Locations.All(l => !l.IsInSource))
                    {
                        continue;
                    }

                    // Namespace + FullName
                    string? ns = NormalizeNamespace(declaredSymbol.ContainingNamespace);
                    string? name = declaredSymbol.Name;

                    // Skip compiler-generated top-level program type (noise + duplicates)
                    if (string.Equals(name, "AutoGeneratedProgram", StringComparison.Ordinal))
                    {
                        continue;
                    }

                    // Skip other compiler-ish names (optional but helps)
                    if (name.StartsWith("<", StringComparison.Ordinal))
                    {
                        continue;
                    }

                    string? fullName = string.IsNullOrWhiteSpace(ns) ? name : $"{ns}.{name}";

                    Domain.Models.TypeKind kind = MapKind(declaredSymbol);

                    string? baseType = declaredSymbol.BaseType is { SpecialType: not SpecialType.System_Object }
                        ? NormalizeFullQualified(declaredSymbol.BaseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                        : null;

                    List<string>? interfaces = declaredSymbol.AllInterfaces
                        .Select(i => NormalizeFullQualified(i.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
                        .Distinct(StringComparer.Ordinal)
                        .ToList();

                    // Member refs (fields + properties)
                    List<MemberTypeRef>? memberRefs = new List<MemberTypeRef>();

                    foreach (ISymbol? member in declaredSymbol.GetMembers())
                    {
                        // Backing fields produce a lot of noise (e.g. "<Kind>k__BackingField")
                        if (member.Name.Contains("k__BackingField", StringComparison.Ordinal))
                        {
                            continue;
                        }

                        if (member is IFieldSymbol field && field.Type is INamedTypeSymbol fType)
                        {
                            memberRefs.Add(new MemberTypeRef(
                                MemberName: field.Name,
                                TargetTypeFullName: NormalizeFullQualified(fType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))));
                        }

                        if (member is IPropertySymbol prop && prop.Type is INamedTypeSymbol pType)
                        {
                            memberRefs.Add(new MemberTypeRef(
                                MemberName: prop.Name,
                                TargetTypeFullName: NormalizeFullQualified(pType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))));
                        }
                    }

                    // Dependencies (constructor DI + member)
                    List<DependencyRef>? deps = new List<DependencyRef>();

                    // Constructor parameter deps (DI)
                    foreach (IMethodSymbol? ctor in declaredSymbol.InstanceConstructors)
                    {
                        // Skip compiler-generated constructors
                        if (ctor.IsImplicitlyDeclared)
                            continue;

                        foreach (IParameterSymbol? p in ctor.Parameters)
                        {
                            if (p.Type is INamedTypeSymbol pType)
                            {
                                deps.Add(new DependencyRef(
                                    SourceTypeFullName: fullName,
                                    TargetTypeFullName: NormalizeFullQualified(pType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)),
                                    Kind: DependencyKind.Constructor,
                                    Label: p.Name));
                            }
                        }
                    }

                    // Member deps (optional, but handy for diagrams)
                    foreach (MemberTypeRef? mr in memberRefs)
                    {
                        deps.Add(new DependencyRef(
                            SourceTypeFullName: fullName,
                            TargetTypeFullName: NormalizeFullQualified(mr.TargetTypeFullName),
                            Kind: DependencyKind.Member,
                            Label: mr.MemberName));
                    }

                    types.Add(new TypeModel(
                        Name: name,
                        Namespace: ns,
                        Kind: kind,
                        FullName: fullName,
                        BaseTypeFullName: baseType,
                        InterfaceFullNames: interfaces,
                        MemberTypeRefs: memberRefs,
                        Dependencies: deps
                    ));
                }
            }

            // De-dup per project (important: traversal can yield duplicates)
            List<TypeModel>? unique = types
                .Where(t => !string.IsNullOrWhiteSpace(t.FullName))
                .GroupBy(t => t.FullName, StringComparer.Ordinal)
                .Select(g => g.First())
                .ToList();

            projects.Add(new ProjectModel(project.Name, unique));
        }

        return new Codebase(projects);
    }

    private static string ResolveEntryPoint(string source)
    {
        if (File.Exists(source) &&
            (source.EndsWith(".sln", StringComparison.OrdinalIgnoreCase) ||
             source.EndsWith(".csproj", StringComparison.OrdinalIgnoreCase)))
        {
            return Path.GetFullPath(source);
        }

        string? dir = Directory.Exists(source) ? source : Path.GetDirectoryName(source);
        if (string.IsNullOrWhiteSpace(dir) || !Directory.Exists(dir))
        {
            throw new ArgumentException($"Source path not found: {source}");
        }

        string? sln = Directory.GetFiles(dir, "*.sln").FirstOrDefault();
        if (sln is not null) return Path.GetFullPath(sln);

        string? csproj = Directory.GetFiles(dir, "*.csproj").FirstOrDefault();
        if (csproj is not null) return Path.GetFullPath(csproj);

        throw new ArgumentException("No .sln or .csproj found in the provided directory.");
    }

    private static Domain.Models.TypeKind MapKind(INamedTypeSymbol symbol)
    {
        if (symbol.TypeKind == Microsoft.CodeAnalysis.TypeKind.Interface) return Domain.Models.TypeKind.Interface;
        if (symbol.TypeKind == Microsoft.CodeAnalysis.TypeKind.Enum) return Domain.Models.TypeKind.Enum;
        if (symbol.TypeKind == Microsoft.CodeAnalysis.TypeKind.Struct) return Domain.Models.TypeKind.Struct;

        return symbol.IsRecord ? Domain.Models.TypeKind.Record : Domain.Models.TypeKind.Class;
    }

    private static string NormalizeNamespace(INamespaceSymbol? ns)
    {
        if (ns is null || ns.IsGlobalNamespace)
        {
            return string.Empty;
        }

        string? text = ns.ToDisplayString();
        return text == "<global namespace>" ? string.Empty : text;
    }

    private static string NormalizeFullQualified(string fq)
        => fq.StartsWith("global::", StringComparison.Ordinal) ? fq["global::".Length..] : fq;
}